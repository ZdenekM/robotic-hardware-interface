In archive libCommLib.a:

comm.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000065e  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000692  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000002  00000000  00000000  00000692  2**0
                  ALLOC
  3 .stab         00000a80  00000000  00000000  00000694  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000dbf  00000000  00000000  00001114  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <crc16_update>:

#endif


uint16_t crc16_update(uint16_t crc, uint8_t a)
    {
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <crc16_update+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <crc16_update+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	9c 83       	std	Y+4, r25	; 0x04
  10:	8b 83       	std	Y+3, r24	; 0x03
  12:	6d 83       	std	Y+5, r22	; 0x05
        int i;

        crc ^= a;
  14:	8d 81       	ldd	r24, Y+5	; 0x05
  16:	28 2f       	mov	r18, r24
  18:	30 e0       	ldi	r19, 0x00	; 0
  1a:	8b 81       	ldd	r24, Y+3	; 0x03
  1c:	9c 81       	ldd	r25, Y+4	; 0x04
  1e:	82 27       	eor	r24, r18
  20:	93 27       	eor	r25, r19
  22:	9c 83       	std	Y+4, r25	; 0x04
  24:	8b 83       	std	Y+3, r24	; 0x03
        for (i = 0; i < 8; ++i)
  26:	1a 82       	std	Y+2, r1	; 0x02
  28:	19 82       	std	Y+1, r1	; 0x01
  2a:	00 c0       	rjmp	.+0      	; 0x2c <crc16_update+0x2c>
        {
            if (crc & 1)
  2c:	8b 81       	ldd	r24, Y+3	; 0x03
  2e:	9c 81       	ldd	r25, Y+4	; 0x04
  30:	81 70       	andi	r24, 0x01	; 1
  32:	90 70       	andi	r25, 0x00	; 0
  34:	88 23       	and	r24, r24
  36:	01 f0       	breq	.+0      	; 0x38 <crc16_update+0x38>
                crc = (crc >> 1) ^ 0xA001;
  38:	8b 81       	ldd	r24, Y+3	; 0x03
  3a:	9c 81       	ldd	r25, Y+4	; 0x04
  3c:	9c 01       	movw	r18, r24
  3e:	36 95       	lsr	r19
  40:	27 95       	ror	r18
  42:	81 e0       	ldi	r24, 0x01	; 1
  44:	90 ea       	ldi	r25, 0xA0	; 160
  46:	82 27       	eor	r24, r18
  48:	93 27       	eor	r25, r19
  4a:	9c 83       	std	Y+4, r25	; 0x04
  4c:	8b 83       	std	Y+3, r24	; 0x03
  4e:	00 c0       	rjmp	.+0      	; 0x50 <crc16_update+0x50>
            else
                crc = (crc >> 1);
  50:	8b 81       	ldd	r24, Y+3	; 0x03
  52:	9c 81       	ldd	r25, Y+4	; 0x04
  54:	96 95       	lsr	r25
  56:	87 95       	ror	r24
  58:	9c 83       	std	Y+4, r25	; 0x04
  5a:	8b 83       	std	Y+3, r24	; 0x03
uint16_t crc16_update(uint16_t crc, uint8_t a)
    {
        int i;

        crc ^= a;
        for (i = 0; i < 8; ++i)
  5c:	89 81       	ldd	r24, Y+1	; 0x01
  5e:	9a 81       	ldd	r25, Y+2	; 0x02
  60:	01 96       	adiw	r24, 0x01	; 1
  62:	9a 83       	std	Y+2, r25	; 0x02
  64:	89 83       	std	Y+1, r24	; 0x01
  66:	89 81       	ldd	r24, Y+1	; 0x01
  68:	9a 81       	ldd	r25, Y+2	; 0x02
  6a:	88 30       	cpi	r24, 0x08	; 8
  6c:	91 05       	cpc	r25, r1
  6e:	04 f0       	brlt	.+0      	; 0x70 <crc16_update+0x70>
                crc = (crc >> 1) ^ 0xA001;
            else
                crc = (crc >> 1);
        }

        return crc;
  70:	8b 81       	ldd	r24, Y+3	; 0x03
  72:	9c 81       	ldd	r25, Y+4	; 0x04
    }
  74:	0f 90       	pop	r0
  76:	0f 90       	pop	r0
  78:	0f 90       	pop	r0
  7a:	0f 90       	pop	r0
  7c:	0f 90       	pop	r0
  7e:	cf 91       	pop	r28
  80:	df 91       	pop	r29
  82:	08 95       	ret

00000084 <makeCRC>:


uint16_t makeCRC(uint8_t *input, uint8_t len)
{
  84:	df 93       	push	r29
  86:	cf 93       	push	r28
  88:	00 d0       	rcall	.+0      	; 0x8a <makeCRC+0x6>
  8a:	00 d0       	rcall	.+0      	; 0x8c <makeCRC+0x8>
  8c:	00 d0       	rcall	.+0      	; 0x8e <makeCRC+0xa>
  8e:	cd b7       	in	r28, 0x3d	; 61
  90:	de b7       	in	r29, 0x3e	; 62
  92:	9d 83       	std	Y+5, r25	; 0x05
  94:	8c 83       	std	Y+4, r24	; 0x04
  96:	6e 83       	std	Y+6, r22	; 0x06
    uint8_t i;
    uint16_t check;

    check=0;
  98:	1a 82       	std	Y+2, r1	; 0x02
  9a:	19 82       	std	Y+1, r1	; 0x01
    for (i=0; i<len; i++)
  9c:	1b 82       	std	Y+3, r1	; 0x03
  9e:	00 c0       	rjmp	.+0      	; 0xa0 <makeCRC+0x1c>
    {
        check = crc16_update(input[i], check);
  a0:	8b 81       	ldd	r24, Y+3	; 0x03
  a2:	28 2f       	mov	r18, r24
  a4:	30 e0       	ldi	r19, 0x00	; 0
  a6:	8c 81       	ldd	r24, Y+4	; 0x04
  a8:	9d 81       	ldd	r25, Y+5	; 0x05
  aa:	fc 01       	movw	r30, r24
  ac:	e2 0f       	add	r30, r18
  ae:	f3 1f       	adc	r31, r19
  b0:	80 81       	ld	r24, Z
  b2:	88 2f       	mov	r24, r24
  b4:	90 e0       	ldi	r25, 0x00	; 0
  b6:	29 81       	ldd	r18, Y+1	; 0x01
  b8:	62 2f       	mov	r22, r18
  ba:	0e 94 00 00 	call	0	; 0x0 <crc16_update>
  be:	9a 83       	std	Y+2, r25	; 0x02
  c0:	89 83       	std	Y+1, r24	; 0x01
{
    uint8_t i;
    uint16_t check;

    check=0;
    for (i=0; i<len; i++)
  c2:	8b 81       	ldd	r24, Y+3	; 0x03
  c4:	8f 5f       	subi	r24, 0xFF	; 255
  c6:	8b 83       	std	Y+3, r24	; 0x03
  c8:	9b 81       	ldd	r25, Y+3	; 0x03
  ca:	8e 81       	ldd	r24, Y+6	; 0x06
  cc:	98 17       	cp	r25, r24
  ce:	00 f0       	brcs	.+0      	; 0xd0 <makeCRC+0x4c>
    {
        check = crc16_update(input[i], check);

    }

    return check;
  d0:	89 81       	ldd	r24, Y+1	; 0x01
  d2:	9a 81       	ldd	r25, Y+2	; 0x02

}
  d4:	26 96       	adiw	r28, 0x06	; 6
  d6:	0f b6       	in	r0, 0x3f	; 63
  d8:	f8 94       	cli
  da:	de bf       	out	0x3e, r29	; 62
  dc:	0f be       	out	0x3f, r0	; 63
  de:	cd bf       	out	0x3d, r28	; 61
  e0:	cf 91       	pop	r28
  e2:	df 91       	pop	r29
  e4:	08 95       	ret

000000e6 <makePacket>:



void makePacket(tpacket *p, uint8_t *data,uint8_t len, uint8_t packet_type, uint8_t addr) {
  e6:	0f 93       	push	r16
  e8:	df 93       	push	r29
  ea:	cf 93       	push	r28
  ec:	cd b7       	in	r28, 0x3d	; 61
  ee:	de b7       	in	r29, 0x3e	; 62
  f0:	27 97       	sbiw	r28, 0x07	; 7
  f2:	0f b6       	in	r0, 0x3f	; 63
  f4:	f8 94       	cli
  f6:	de bf       	out	0x3e, r29	; 62
  f8:	0f be       	out	0x3f, r0	; 63
  fa:	cd bf       	out	0x3d, r28	; 61
  fc:	9a 83       	std	Y+2, r25	; 0x02
  fe:	89 83       	std	Y+1, r24	; 0x01
 100:	7c 83       	std	Y+4, r23	; 0x04
 102:	6b 83       	std	Y+3, r22	; 0x03
 104:	4d 83       	std	Y+5, r20	; 0x05
 106:	2e 83       	std	Y+6, r18	; 0x06
 108:	0f 83       	std	Y+7, r16	; 0x07

		// alokování paketu


		p->addr = addr;
 10a:	e9 81       	ldd	r30, Y+1	; 0x01
 10c:	fa 81       	ldd	r31, Y+2	; 0x02
 10e:	8f 81       	ldd	r24, Y+7	; 0x07
 110:	84 a3       	std	Z+36, r24	; 0x24
		p->len = len;
 112:	e9 81       	ldd	r30, Y+1	; 0x01
 114:	fa 81       	ldd	r31, Y+2	; 0x02
 116:	8d 81       	ldd	r24, Y+5	; 0x05
 118:	80 a3       	std	Z+32, r24	; 0x20
		p->packet_type = packet_type;
 11a:	e9 81       	ldd	r30, Y+1	; 0x01
 11c:	fa 81       	ldd	r31, Y+2	; 0x02
 11e:	8e 81       	ldd	r24, Y+6	; 0x06
 120:	81 a3       	std	Z+33, r24	; 0x21
		p->crc = makeCRC(&data,len);
 122:	ce 01       	movw	r24, r28
 124:	03 96       	adiw	r24, 0x03	; 3
 126:	6d 81       	ldd	r22, Y+5	; 0x05
 128:	0e 94 00 00 	call	0	; 0x0 <crc16_update>
 12c:	e9 81       	ldd	r30, Y+1	; 0x01
 12e:	fa 81       	ldd	r31, Y+2	; 0x02
 130:	93 a3       	std	Z+35, r25	; 0x23
 132:	82 a3       	std	Z+34, r24	; 0x22

		// kopírování dat
		if (len < BUFF_LEN) memcpy(&p->data,&data,len);
 134:	8d 81       	ldd	r24, Y+5	; 0x05
 136:	80 32       	cpi	r24, 0x20	; 32
 138:	00 f4       	brcc	.+0      	; 0x13a <makePacket+0x54>
 13a:	49 81       	ldd	r20, Y+1	; 0x01
 13c:	5a 81       	ldd	r21, Y+2	; 0x02
 13e:	8d 81       	ldd	r24, Y+5	; 0x05
 140:	e8 2f       	mov	r30, r24
 142:	f0 e0       	ldi	r31, 0x00	; 0
 144:	9e 01       	movw	r18, r28
 146:	2d 5f       	subi	r18, 0xFD	; 253
 148:	3f 4f       	sbci	r19, 0xFF	; 255
 14a:	ca 01       	movw	r24, r20
 14c:	b9 01       	movw	r22, r18
 14e:	af 01       	movw	r20, r30
 150:	0e 94 00 00 	call	0	; 0x0 <crc16_update>



}
 154:	27 96       	adiw	r28, 0x07	; 7
 156:	0f b6       	in	r0, 0x3f	; 63
 158:	f8 94       	cli
 15a:	de bf       	out	0x3e, r29	; 62
 15c:	0f be       	out	0x3f, r0	; 63
 15e:	cd bf       	out	0x3d, r28	; 61
 160:	cf 91       	pop	r28
 162:	df 91       	pop	r29
 164:	0f 91       	pop	r16
 166:	08 95       	ret

00000168 <sendFirstByte>:

// zahájení pøenosu - odeslání prvního bytu
void sendFirstByte(volatile uint8_t *tUDR, volatile tcomm_state *c) {
 168:	df 93       	push	r29
 16a:	cf 93       	push	r28
 16c:	00 d0       	rcall	.+0      	; 0x16e <sendFirstByte+0x6>
 16e:	00 d0       	rcall	.+0      	; 0x170 <sendFirstByte+0x8>
 170:	cd b7       	in	r28, 0x3d	; 61
 172:	de b7       	in	r29, 0x3e	; 62
 174:	9a 83       	std	Y+2, r25	; 0x02
 176:	89 83       	std	Y+1, r24	; 0x01
 178:	7c 83       	std	Y+4, r23	; 0x04
 17a:	6b 83       	std	Y+3, r22	; 0x03

	c->send_state = PS_SYNC1;
 17c:	eb 81       	ldd	r30, Y+3	; 0x03
 17e:	fc 81       	ldd	r31, Y+4	; 0x04
 180:	10 82       	st	Z, r1

	*tUDR = SYNC1;
 182:	e9 81       	ldd	r30, Y+1	; 0x01
 184:	fa 81       	ldd	r31, Y+2	; 0x02
 186:	8a ea       	ldi	r24, 0xAA	; 170
 188:	80 83       	st	Z, r24

}
 18a:	0f 90       	pop	r0
 18c:	0f 90       	pop	r0
 18e:	0f 90       	pop	r0
 190:	0f 90       	pop	r0
 192:	cf 91       	pop	r28
 194:	df 91       	pop	r29
 196:	08 95       	ret

00000198 <sendPacket>:

// TODO: nastavování devátého bitu
// funkce volaná z pøerušení TX_Complete
// PS_SYNC1, PS_SYNC2, PS_ADDR, PS_LEN, PS_TYPE, PS_DATA, PS_CRC1, PS_CRC2, PS_READY
void sendPacket(volatile uint8_t *tUDR, volatile tcomm_state *c) {
 198:	df 93       	push	r29
 19a:	cf 93       	push	r28
 19c:	00 d0       	rcall	.+0      	; 0x19e <sendPacket+0x6>
 19e:	00 d0       	rcall	.+0      	; 0x1a0 <sendPacket+0x8>
 1a0:	00 d0       	rcall	.+0      	; 0x1a2 <sendPacket+0xa>
 1a2:	cd b7       	in	r28, 0x3d	; 61
 1a4:	de b7       	in	r29, 0x3e	; 62
 1a6:	9a 83       	std	Y+2, r25	; 0x02
 1a8:	89 83       	std	Y+1, r24	; 0x01
 1aa:	7c 83       	std	Y+4, r23	; 0x04
 1ac:	6b 83       	std	Y+3, r22	; 0x03

	static uint8_t index = 0;

	switch (c->send_state) {
 1ae:	eb 81       	ldd	r30, Y+3	; 0x03
 1b0:	fc 81       	ldd	r31, Y+4	; 0x04
 1b2:	80 81       	ld	r24, Z
 1b4:	28 2f       	mov	r18, r24
 1b6:	30 e0       	ldi	r19, 0x00	; 0
 1b8:	3e 83       	std	Y+6, r19	; 0x06
 1ba:	2d 83       	std	Y+5, r18	; 0x05
 1bc:	8d 81       	ldd	r24, Y+5	; 0x05
 1be:	9e 81       	ldd	r25, Y+6	; 0x06
 1c0:	83 30       	cpi	r24, 0x03	; 3
 1c2:	91 05       	cpc	r25, r1
 1c4:	01 f4       	brne	.+0      	; 0x1c6 <sendPacket+0x2e>
 1c6:	00 c0       	rjmp	.+0      	; 0x1c8 <sendPacket+0x30>
 1c8:	2d 81       	ldd	r18, Y+5	; 0x05
 1ca:	3e 81       	ldd	r19, Y+6	; 0x06
 1cc:	24 30       	cpi	r18, 0x04	; 4
 1ce:	31 05       	cpc	r19, r1
 1d0:	04 f4       	brge	.+0      	; 0x1d2 <sendPacket+0x3a>
 1d2:	8d 81       	ldd	r24, Y+5	; 0x05
 1d4:	9e 81       	ldd	r25, Y+6	; 0x06
 1d6:	81 30       	cpi	r24, 0x01	; 1
 1d8:	91 05       	cpc	r25, r1
 1da:	01 f0       	breq	.+0      	; 0x1dc <sendPacket+0x44>
 1dc:	2d 81       	ldd	r18, Y+5	; 0x05
 1de:	3e 81       	ldd	r19, Y+6	; 0x06
 1e0:	22 30       	cpi	r18, 0x02	; 2
 1e2:	31 05       	cpc	r19, r1
 1e4:	04 f4       	brge	.+0      	; 0x1e6 <sendPacket+0x4e>
 1e6:	8d 81       	ldd	r24, Y+5	; 0x05
 1e8:	9e 81       	ldd	r25, Y+6	; 0x06
 1ea:	00 97       	sbiw	r24, 0x00	; 0
 1ec:	01 f0       	breq	.+0      	; 0x1ee <sendPacket+0x56>
 1ee:	00 c0       	rjmp	.+0      	; 0x1f0 <sendPacket+0x58>
 1f0:	2d 81       	ldd	r18, Y+5	; 0x05
 1f2:	3e 81       	ldd	r19, Y+6	; 0x06
 1f4:	25 30       	cpi	r18, 0x05	; 5
 1f6:	31 05       	cpc	r19, r1
 1f8:	01 f4       	brne	.+0      	; 0x1fa <sendPacket+0x62>
 1fa:	00 c0       	rjmp	.+0      	; 0x1fc <sendPacket+0x64>
 1fc:	8d 81       	ldd	r24, Y+5	; 0x05
 1fe:	9e 81       	ldd	r25, Y+6	; 0x06
 200:	85 30       	cpi	r24, 0x05	; 5
 202:	91 05       	cpc	r25, r1
 204:	04 f0       	brlt	.+0      	; 0x206 <sendPacket+0x6e>
 206:	2d 81       	ldd	r18, Y+5	; 0x05
 208:	3e 81       	ldd	r19, Y+6	; 0x06
 20a:	26 30       	cpi	r18, 0x06	; 6
 20c:	31 05       	cpc	r19, r1
 20e:	01 f4       	brne	.+0      	; 0x210 <sendPacket+0x78>
 210:	00 c0       	rjmp	.+0      	; 0x212 <sendPacket+0x7a>
 212:	8d 81       	ldd	r24, Y+5	; 0x05
 214:	9e 81       	ldd	r25, Y+6	; 0x06
 216:	87 30       	cpi	r24, 0x07	; 7
 218:	91 05       	cpc	r25, r1
 21a:	01 f4       	brne	.+0      	; 0x21c <sendPacket+0x84>
 21c:	00 c0       	rjmp	.+0      	; 0x21e <sendPacket+0x86>
 21e:	00 c0       	rjmp	.+0      	; 0x220 <sendPacket+0x88>

		case PS_SYNC1: {
			// odeslání druhého s. bytu
			c->send_state = PS_SYNC2;
 220:	eb 81       	ldd	r30, Y+3	; 0x03
 222:	fc 81       	ldd	r31, Y+4	; 0x04
 224:	81 e0       	ldi	r24, 0x01	; 1
 226:	80 83       	st	Z, r24
			*tUDR = SYNC2;
 228:	e9 81       	ldd	r30, Y+1	; 0x01
 22a:	fa 81       	ldd	r31, Y+2	; 0x02
 22c:	8b ea       	ldi	r24, 0xAB	; 171
 22e:	80 83       	st	Z, r24
 230:	00 c0       	rjmp	.+0      	; 0x232 <sendPacket+0x9a>

		} break;

		case PS_SYNC2: {
			// odeslání adresy pøíjemce
			c->send_state = PS_ADDR;
 232:	eb 81       	ldd	r30, Y+3	; 0x03
 234:	fc 81       	ldd	r31, Y+4	; 0x04
 236:	82 e0       	ldi	r24, 0x02	; 2
 238:	80 83       	st	Z, r24
			*tUDR = c->op.addr;
 23a:	eb 81       	ldd	r30, Y+3	; 0x03
 23c:	fc 81       	ldd	r31, Y+4	; 0x04
 23e:	87 a1       	ldd	r24, Z+39	; 0x27
 240:	e9 81       	ldd	r30, Y+1	; 0x01
 242:	fa 81       	ldd	r31, Y+2	; 0x02
 244:	80 83       	st	Z, r24
 246:	00 c0       	rjmp	.+0      	; 0x248 <sendPacket+0xb0>

		} break;

		case PS_ADDR: {
			// délka data
			c->send_state = PS_LEN;
 248:	eb 81       	ldd	r30, Y+3	; 0x03
 24a:	fc 81       	ldd	r31, Y+4	; 0x04
 24c:	83 e0       	ldi	r24, 0x03	; 3
 24e:	80 83       	st	Z, r24
			*tUDR = c->op.len;
 250:	eb 81       	ldd	r30, Y+3	; 0x03
 252:	fc 81       	ldd	r31, Y+4	; 0x04
 254:	83 a1       	ldd	r24, Z+35	; 0x23
 256:	e9 81       	ldd	r30, Y+1	; 0x01
 258:	fa 81       	ldd	r31, Y+2	; 0x02
 25a:	80 83       	st	Z, r24
 25c:	00 c0       	rjmp	.+0      	; 0x25e <sendPacket+0xc6>

		} break;

		case PS_LEN: {
			// typ paketu
			c->send_state = PS_TYPE;
 25e:	eb 81       	ldd	r30, Y+3	; 0x03
 260:	fc 81       	ldd	r31, Y+4	; 0x04
 262:	84 e0       	ldi	r24, 0x04	; 4
 264:	80 83       	st	Z, r24
			*tUDR = c->op.packet_type;
 266:	eb 81       	ldd	r30, Y+3	; 0x03
 268:	fc 81       	ldd	r31, Y+4	; 0x04
 26a:	84 a1       	ldd	r24, Z+36	; 0x24
 26c:	e9 81       	ldd	r30, Y+1	; 0x01
 26e:	fa 81       	ldd	r31, Y+2	; 0x02
 270:	80 83       	st	Z, r24
 272:	00 c0       	rjmp	.+0      	; 0x274 <sendPacket+0xdc>

		} break;

		case PS_TYPE: {
			// odeslání prvního bytu obsahu
			c->send_state = PS_DATA;
 274:	eb 81       	ldd	r30, Y+3	; 0x03
 276:	fc 81       	ldd	r31, Y+4	; 0x04
 278:	85 e0       	ldi	r24, 0x05	; 5
 27a:	80 83       	st	Z, r24
			*tUDR = c->op.data[index++];
 27c:	40 91 00 00 	lds	r20, 0x0000
 280:	24 2f       	mov	r18, r20
 282:	30 e0       	ldi	r19, 0x00	; 0
 284:	8b 81       	ldd	r24, Y+3	; 0x03
 286:	9c 81       	ldd	r25, Y+4	; 0x04
 288:	82 0f       	add	r24, r18
 28a:	93 1f       	adc	r25, r19
 28c:	fc 01       	movw	r30, r24
 28e:	33 96       	adiw	r30, 0x03	; 3
 290:	80 81       	ld	r24, Z
 292:	e9 81       	ldd	r30, Y+1	; 0x01
 294:	fa 81       	ldd	r31, Y+2	; 0x02
 296:	80 83       	st	Z, r24
 298:	84 2f       	mov	r24, r20
 29a:	8f 5f       	subi	r24, 0xFF	; 255
 29c:	80 93 00 00 	sts	0x0000, r24
 2a0:	00 c0       	rjmp	.+0      	; 0x2a2 <sendPacket+0x10a>

		} break;

		case PS_DATA: {
			// odesílání obsahu paketu
			if (index < c->op.len) *tUDR = c->op.data[index++];
 2a2:	eb 81       	ldd	r30, Y+3	; 0x03
 2a4:	fc 81       	ldd	r31, Y+4	; 0x04
 2a6:	93 a1       	ldd	r25, Z+35	; 0x23
 2a8:	80 91 00 00 	lds	r24, 0x0000
 2ac:	89 17       	cp	r24, r25
 2ae:	00 f4       	brcc	.+0      	; 0x2b0 <sendPacket+0x118>
 2b0:	40 91 00 00 	lds	r20, 0x0000
 2b4:	24 2f       	mov	r18, r20
 2b6:	30 e0       	ldi	r19, 0x00	; 0
 2b8:	8b 81       	ldd	r24, Y+3	; 0x03
 2ba:	9c 81       	ldd	r25, Y+4	; 0x04
 2bc:	82 0f       	add	r24, r18
 2be:	93 1f       	adc	r25, r19
 2c0:	fc 01       	movw	r30, r24
 2c2:	33 96       	adiw	r30, 0x03	; 3
 2c4:	80 81       	ld	r24, Z
 2c6:	e9 81       	ldd	r30, Y+1	; 0x01
 2c8:	fa 81       	ldd	r31, Y+2	; 0x02
 2ca:	80 83       	st	Z, r24
 2cc:	84 2f       	mov	r24, r20
 2ce:	8f 5f       	subi	r24, 0xFF	; 255
 2d0:	80 93 00 00 	sts	0x0000, r24
 2d4:	00 c0       	rjmp	.+0      	; 0x2d6 <sendPacket+0x13e>
			else {
				// spodní byte CRC
				c->send_state = PS_CRC1;
 2d6:	eb 81       	ldd	r30, Y+3	; 0x03
 2d8:	fc 81       	ldd	r31, Y+4	; 0x04
 2da:	86 e0       	ldi	r24, 0x06	; 6
 2dc:	80 83       	st	Z, r24
				index = 0;
 2de:	10 92 00 00 	sts	0x0000, r1
				// vynulovani horniho bytu
				*tUDR = (uint8_t)(c->op.crc&0xFF);
 2e2:	eb 81       	ldd	r30, Y+3	; 0x03
 2e4:	fc 81       	ldd	r31, Y+4	; 0x04
 2e6:	85 a1       	ldd	r24, Z+37	; 0x25
 2e8:	96 a1       	ldd	r25, Z+38	; 0x26
 2ea:	e9 81       	ldd	r30, Y+1	; 0x01
 2ec:	fa 81       	ldd	r31, Y+2	; 0x02
 2ee:	80 83       	st	Z, r24
 2f0:	00 c0       	rjmp	.+0      	; 0x2f2 <sendPacket+0x15a>

		} break;

		case PS_CRC1: {
			// horní byte CRC
			c->send_state = PS_CRC2;
 2f2:	eb 81       	ldd	r30, Y+3	; 0x03
 2f4:	fc 81       	ldd	r31, Y+4	; 0x04
 2f6:	87 e0       	ldi	r24, 0x07	; 7
 2f8:	80 83       	st	Z, r24
			*tUDR = (uint8_t)(c->op.crc>>8);
 2fa:	eb 81       	ldd	r30, Y+3	; 0x03
 2fc:	fc 81       	ldd	r31, Y+4	; 0x04
 2fe:	85 a1       	ldd	r24, Z+37	; 0x25
 300:	96 a1       	ldd	r25, Z+38	; 0x26
 302:	89 2f       	mov	r24, r25
 304:	99 27       	eor	r25, r25
 306:	e9 81       	ldd	r30, Y+1	; 0x01
 308:	fa 81       	ldd	r31, Y+2	; 0x02
 30a:	80 83       	st	Z, r24
 30c:	00 c0       	rjmp	.+0      	; 0x30e <sendPacket+0x176>

		} break;

		case PS_CRC2: {
			// konec pøenosu paketu
			c->send_state = PS_READY;
 30e:	eb 81       	ldd	r30, Y+3	; 0x03
 310:	fc 81       	ldd	r31, Y+4	; 0x04
 312:	88 e0       	ldi	r24, 0x08	; 8
 314:	80 83       	st	Z, r24
			c->packets_sended++;
 316:	eb 81       	ldd	r30, Y+3	; 0x03
 318:	fc 81       	ldd	r31, Y+4	; 0x04
 31a:	80 a5       	ldd	r24, Z+40	; 0x28
 31c:	91 a5       	ldd	r25, Z+41	; 0x29
 31e:	a2 a5       	ldd	r26, Z+42	; 0x2a
 320:	b3 a5       	ldd	r27, Z+43	; 0x2b
 322:	01 96       	adiw	r24, 0x01	; 1
 324:	a1 1d       	adc	r26, r1
 326:	b1 1d       	adc	r27, r1
 328:	eb 81       	ldd	r30, Y+3	; 0x03
 32a:	fc 81       	ldd	r31, Y+4	; 0x04
 32c:	80 a7       	std	Z+40, r24	; 0x28
 32e:	91 a7       	std	Z+41, r25	; 0x29
 330:	a2 a7       	std	Z+42, r26	; 0x2a
 332:	b3 a7       	std	Z+43, r27	; 0x2b
		//case PS_READY: break;


	}

}
 334:	26 96       	adiw	r28, 0x06	; 6
 336:	0f b6       	in	r0, 0x3f	; 63
 338:	f8 94       	cli
 33a:	de bf       	out	0x3e, r29	; 62
 33c:	0f be       	out	0x3f, r0	; 63
 33e:	cd bf       	out	0x3d, r28	; 61
 340:	cf 91       	pop	r28
 342:	df 91       	pop	r29
 344:	08 95       	ret

00000346 <comm_state_init>:

// inicializace struktury typu tcomm_state
void comm_state_init(volatile tcomm_state *c) {
 346:	df 93       	push	r29
 348:	cf 93       	push	r28
 34a:	00 d0       	rcall	.+0      	; 0x34c <comm_state_init+0x6>
 34c:	cd b7       	in	r28, 0x3d	; 61
 34e:	de b7       	in	r29, 0x3e	; 62
 350:	9a 83       	std	Y+2, r25	; 0x02
 352:	89 83       	std	Y+1, r24	; 0x01

	if (c!=NULL) {
 354:	89 81       	ldd	r24, Y+1	; 0x01
 356:	9a 81       	ldd	r25, Y+2	; 0x02
 358:	00 97       	sbiw	r24, 0x00	; 0
 35a:	01 f0       	breq	.+0      	; 0x35c <comm_state_init+0x16>

		c->send_state = PS_READY;
 35c:	e9 81       	ldd	r30, Y+1	; 0x01
 35e:	fa 81       	ldd	r31, Y+2	; 0x02
 360:	88 e0       	ldi	r24, 0x08	; 8
 362:	80 83       	st	Z, r24
		c->receive_state = PR_READY;
 364:	e9 81       	ldd	r30, Y+1	; 0x01
 366:	fa 81       	ldd	r31, Y+2	; 0x02
 368:	8a e0       	ldi	r24, 0x0A	; 10
 36a:	81 83       	std	Z+1, r24	; 0x01
		c->packets_sended = 0;
 36c:	e9 81       	ldd	r30, Y+1	; 0x01
 36e:	fa 81       	ldd	r31, Y+2	; 0x02
 370:	10 a6       	std	Z+40, r1	; 0x28
 372:	11 a6       	std	Z+41, r1	; 0x29
 374:	12 a6       	std	Z+42, r1	; 0x2a
 376:	13 a6       	std	Z+43, r1	; 0x2b
		c->receive_timeout = 0;
 378:	e9 81       	ldd	r30, Y+1	; 0x01
 37a:	fa 81       	ldd	r31, Y+2	; 0x02
 37c:	12 82       	std	Z+2, r1	; 0x02
		c->packets_bad_received = 0;
 37e:	e9 81       	ldd	r30, Y+1	; 0x01
 380:	fa 81       	ldd	r31, Y+2	; 0x02
 382:	11 aa       	std	Z+49, r1	; 0x31
 384:	10 aa       	std	Z+48, r1	; 0x30
		c->packets_received = 0;
 386:	e9 81       	ldd	r30, Y+1	; 0x01
 388:	fa 81       	ldd	r31, Y+2	; 0x02
 38a:	14 a6       	std	Z+44, r1	; 0x2c
 38c:	15 a6       	std	Z+45, r1	; 0x2d
 38e:	16 a6       	std	Z+46, r1	; 0x2e
 390:	17 a6       	std	Z+47, r1	; 0x2f
		c->packets_timeouted = 0;
 392:	e9 81       	ldd	r30, Y+1	; 0x01
 394:	fa 81       	ldd	r31, Y+2	; 0x02
 396:	13 aa       	std	Z+51, r1	; 0x33
 398:	12 aa       	std	Z+50, r1	; 0x32
		c->frame_error = 0;
 39a:	e9 81       	ldd	r30, Y+1	; 0x01
 39c:	fa 81       	ldd	r31, Y+2	; 0x02
 39e:	15 aa       	std	Z+53, r1	; 0x35
 3a0:	14 aa       	std	Z+52, r1	; 0x34


	}

}
 3a2:	0f 90       	pop	r0
 3a4:	0f 90       	pop	r0
 3a6:	cf 91       	pop	r28
 3a8:	df 91       	pop	r29
 3aa:	08 95       	ret

000003ac <receivePacket>:


// TODO: dodìlat pøíjem paketù podle 9. bitu
// PR_SYNC1, PR_SYNC2, PR_ADDR, PR_LEN, PR_TYPE, PR_DATA, PR_CRC1, PR_CRC2, PR_PACKET_RECEIVED, PR_READY
void receivePacket(uint8_t tUDR, volatile tcomm_state *c) {
 3ac:	df 93       	push	r29
 3ae:	cf 93       	push	r28
 3b0:	cd b7       	in	r28, 0x3d	; 61
 3b2:	de b7       	in	r29, 0x3e	; 62
 3b4:	29 97       	sbiw	r28, 0x09	; 9
 3b6:	0f b6       	in	r0, 0x3f	; 63
 3b8:	f8 94       	cli
 3ba:	de bf       	out	0x3e, r29	; 62
 3bc:	0f be       	out	0x3f, r0	; 63
 3be:	cd bf       	out	0x3d, r28	; 61
 3c0:	8d 83       	std	Y+5, r24	; 0x05
 3c2:	7f 83       	std	Y+7, r23	; 0x07
 3c4:	6e 83       	std	Y+6, r22	; 0x06

	static uint8_t index = 0;

	c->receive_timeout = 0;
 3c6:	ee 81       	ldd	r30, Y+6	; 0x06
 3c8:	ff 81       	ldd	r31, Y+7	; 0x07
 3ca:	12 82       	std	Z+2, r1	; 0x02

	//if (c!=NULL) {

	switch (c->receive_state) {
 3cc:	ee 81       	ldd	r30, Y+6	; 0x06
 3ce:	ff 81       	ldd	r31, Y+7	; 0x07
 3d0:	81 81       	ldd	r24, Z+1	; 0x01
 3d2:	28 2f       	mov	r18, r24
 3d4:	30 e0       	ldi	r19, 0x00	; 0
 3d6:	39 87       	std	Y+9, r19	; 0x09
 3d8:	28 87       	std	Y+8, r18	; 0x08
 3da:	88 85       	ldd	r24, Y+8	; 0x08
 3dc:	99 85       	ldd	r25, Y+9	; 0x09
 3de:	84 30       	cpi	r24, 0x04	; 4
 3e0:	91 05       	cpc	r25, r1
 3e2:	01 f4       	brne	.+0      	; 0x3e4 <receivePacket+0x38>
 3e4:	00 c0       	rjmp	.+0      	; 0x3e6 <receivePacket+0x3a>
 3e6:	28 85       	ldd	r18, Y+8	; 0x08
 3e8:	39 85       	ldd	r19, Y+9	; 0x09
 3ea:	25 30       	cpi	r18, 0x05	; 5
 3ec:	31 05       	cpc	r19, r1
 3ee:	04 f4       	brge	.+0      	; 0x3f0 <receivePacket+0x44>
 3f0:	88 85       	ldd	r24, Y+8	; 0x08
 3f2:	99 85       	ldd	r25, Y+9	; 0x09
 3f4:	82 30       	cpi	r24, 0x02	; 2
 3f6:	91 05       	cpc	r25, r1
 3f8:	01 f4       	brne	.+0      	; 0x3fa <receivePacket+0x4e>
 3fa:	00 c0       	rjmp	.+0      	; 0x3fc <receivePacket+0x50>
 3fc:	28 85       	ldd	r18, Y+8	; 0x08
 3fe:	39 85       	ldd	r19, Y+9	; 0x09
 400:	23 30       	cpi	r18, 0x03	; 3
 402:	31 05       	cpc	r19, r1
 404:	04 f0       	brlt	.+0      	; 0x406 <receivePacket+0x5a>
 406:	00 c0       	rjmp	.+0      	; 0x408 <receivePacket+0x5c>
 408:	88 85       	ldd	r24, Y+8	; 0x08
 40a:	99 85       	ldd	r25, Y+9	; 0x09
 40c:	81 30       	cpi	r24, 0x01	; 1
 40e:	91 05       	cpc	r25, r1
 410:	01 f0       	breq	.+0      	; 0x412 <receivePacket+0x66>
 412:	00 c0       	rjmp	.+0      	; 0x414 <receivePacket+0x68>
 414:	28 85       	ldd	r18, Y+8	; 0x08
 416:	39 85       	ldd	r19, Y+9	; 0x09
 418:	26 30       	cpi	r18, 0x06	; 6
 41a:	31 05       	cpc	r19, r1
 41c:	01 f4       	brne	.+0      	; 0x41e <receivePacket+0x72>
 41e:	00 c0       	rjmp	.+0      	; 0x420 <receivePacket+0x74>
 420:	88 85       	ldd	r24, Y+8	; 0x08
 422:	99 85       	ldd	r25, Y+9	; 0x09
 424:	86 30       	cpi	r24, 0x06	; 6
 426:	91 05       	cpc	r25, r1
 428:	04 f4       	brge	.+0      	; 0x42a <receivePacket+0x7e>
 42a:	00 c0       	rjmp	.+0      	; 0x42c <receivePacket+0x80>
 42c:	28 85       	ldd	r18, Y+8	; 0x08
 42e:	39 85       	ldd	r19, Y+9	; 0x09
 430:	27 30       	cpi	r18, 0x07	; 7
 432:	31 05       	cpc	r19, r1
 434:	01 f4       	brne	.+0      	; 0x436 <receivePacket+0x8a>
 436:	00 c0       	rjmp	.+0      	; 0x438 <receivePacket+0x8c>
 438:	88 85       	ldd	r24, Y+8	; 0x08
 43a:	99 85       	ldd	r25, Y+9	; 0x09
 43c:	8a 30       	cpi	r24, 0x0A	; 10
 43e:	91 05       	cpc	r25, r1
 440:	01 f0       	breq	.+0      	; 0x442 <receivePacket+0x96>
 442:	00 c0       	rjmp	.+0      	; 0x444 <receivePacket+0x98>

	case PR_READY: {

		if (tUDR==SYNC1) c->receive_state = PR_SYNC2;
 444:	8d 81       	ldd	r24, Y+5	; 0x05
 446:	8a 3a       	cpi	r24, 0xAA	; 170
 448:	01 f4       	brne	.+0      	; 0x44a <receivePacket+0x9e>
 44a:	ee 81       	ldd	r30, Y+6	; 0x06
 44c:	ff 81       	ldd	r31, Y+7	; 0x07
 44e:	81 e0       	ldi	r24, 0x01	; 1
 450:	81 83       	std	Z+1, r24	; 0x01
 452:	00 c0       	rjmp	.+0      	; 0x454 <receivePacket+0xa8>
		else c->receive_state = PR_READY;
 454:	ee 81       	ldd	r30, Y+6	; 0x06
 456:	ff 81       	ldd	r31, Y+7	; 0x07
 458:	8a e0       	ldi	r24, 0x0A	; 10
 45a:	81 83       	std	Z+1, r24	; 0x01
 45c:	00 c0       	rjmp	.+0      	; 0x45e <receivePacket+0xb2>

	} break;

	case PR_SYNC2:  {

		if (tUDR==SYNC2) c->receive_state = PR_ADDR;
 45e:	8d 81       	ldd	r24, Y+5	; 0x05
 460:	8b 3a       	cpi	r24, 0xAB	; 171
 462:	01 f4       	brne	.+0      	; 0x464 <receivePacket+0xb8>
 464:	ee 81       	ldd	r30, Y+6	; 0x06
 466:	ff 81       	ldd	r31, Y+7	; 0x07
 468:	82 e0       	ldi	r24, 0x02	; 2
 46a:	81 83       	std	Z+1, r24	; 0x01
 46c:	00 c0       	rjmp	.+0      	; 0x46e <receivePacket+0xc2>
		else c->receive_state = PR_READY;
 46e:	ee 81       	ldd	r30, Y+6	; 0x06
 470:	ff 81       	ldd	r31, Y+7	; 0x07
 472:	8a e0       	ldi	r24, 0x0A	; 10
 474:	81 83       	std	Z+1, r24	; 0x01
 476:	00 c0       	rjmp	.+0      	; 0x478 <receivePacket+0xcc>

	} break;

	case PR_ADDR: {

		c->receive_state = PR_LEN;
 478:	ee 81       	ldd	r30, Y+6	; 0x06
 47a:	ff 81       	ldd	r31, Y+7	; 0x07
 47c:	83 e0       	ldi	r24, 0x03	; 3
 47e:	81 83       	std	Z+1, r24	; 0x01
		// TODO: porovnání pøijaté adresy s vlastní
		c->ip.addr = tUDR;
 480:	8e 81       	ldd	r24, Y+6	; 0x06
 482:	9f 81       	ldd	r25, Y+7	; 0x07
 484:	fc 01       	movw	r30, r24
 486:	e6 5a       	subi	r30, 0xA6	; 166
 488:	ff 4f       	sbci	r31, 0xFF	; 255
 48a:	8d 81       	ldd	r24, Y+5	; 0x05
 48c:	80 83       	st	Z, r24
 48e:	00 c0       	rjmp	.+0      	; 0x490 <receivePacket+0xe4>

	} break;

	case PR_LEN: {

		if (tUDR<BUFF_LEN) {
 490:	8d 81       	ldd	r24, Y+5	; 0x05
 492:	80 32       	cpi	r24, 0x20	; 32
 494:	00 f4       	brcc	.+0      	; 0x496 <receivePacket+0xea>

			c->receive_state = PR_TYPE;
 496:	ee 81       	ldd	r30, Y+6	; 0x06
 498:	ff 81       	ldd	r31, Y+7	; 0x07
 49a:	84 e0       	ldi	r24, 0x04	; 4
 49c:	81 83       	std	Z+1, r24	; 0x01
			c->ip.len = tUDR;
 49e:	8e 81       	ldd	r24, Y+6	; 0x06
 4a0:	9f 81       	ldd	r25, Y+7	; 0x07
 4a2:	fc 01       	movw	r30, r24
 4a4:	ea 5a       	subi	r30, 0xAA	; 170
 4a6:	ff 4f       	sbci	r31, 0xFF	; 255
 4a8:	8d 81       	ldd	r24, Y+5	; 0x05
 4aa:	80 83       	st	Z, r24
 4ac:	00 c0       	rjmp	.+0      	; 0x4ae <receivePacket+0x102>

		} else	c->receive_state = PR_READY;
 4ae:	ee 81       	ldd	r30, Y+6	; 0x06
 4b0:	ff 81       	ldd	r31, Y+7	; 0x07
 4b2:	8a e0       	ldi	r24, 0x0A	; 10
 4b4:	81 83       	std	Z+1, r24	; 0x01
 4b6:	00 c0       	rjmp	.+0      	; 0x4b8 <receivePacket+0x10c>

	} break;

	case PR_TYPE: {

		c->receive_state = PR_DATA;
 4b8:	ee 81       	ldd	r30, Y+6	; 0x06
 4ba:	ff 81       	ldd	r31, Y+7	; 0x07
 4bc:	85 e0       	ldi	r24, 0x05	; 5
 4be:	81 83       	std	Z+1, r24	; 0x01
		c->ip.packet_type = tUDR;
 4c0:	8e 81       	ldd	r24, Y+6	; 0x06
 4c2:	9f 81       	ldd	r25, Y+7	; 0x07
 4c4:	fc 01       	movw	r30, r24
 4c6:	e9 5a       	subi	r30, 0xA9	; 169
 4c8:	ff 4f       	sbci	r31, 0xFF	; 255
 4ca:	8d 81       	ldd	r24, Y+5	; 0x05
 4cc:	80 83       	st	Z, r24
 4ce:	00 c0       	rjmp	.+0      	; 0x4d0 <receivePacket+0x124>

	} break;

	case PR_DATA: {

		c->ip.data[index++] = tUDR;
 4d0:	40 91 00 00 	lds	r20, 0x0000
 4d4:	24 2f       	mov	r18, r20
 4d6:	30 e0       	ldi	r19, 0x00	; 0
 4d8:	8e 81       	ldd	r24, Y+6	; 0x06
 4da:	9f 81       	ldd	r25, Y+7	; 0x07
 4dc:	82 0f       	add	r24, r18
 4de:	93 1f       	adc	r25, r19
 4e0:	fc 01       	movw	r30, r24
 4e2:	f6 96       	adiw	r30, 0x36	; 54
 4e4:	8d 81       	ldd	r24, Y+5	; 0x05
 4e6:	80 83       	st	Z, r24
 4e8:	84 2f       	mov	r24, r20
 4ea:	8f 5f       	subi	r24, 0xFF	; 255
 4ec:	80 93 00 00 	sts	0x0000, r24

		// pøíjem dat dokonèen
		if (index==c->ip.len) {
 4f0:	8e 81       	ldd	r24, Y+6	; 0x06
 4f2:	9f 81       	ldd	r25, Y+7	; 0x07
 4f4:	fc 01       	movw	r30, r24
 4f6:	ea 5a       	subi	r30, 0xAA	; 170
 4f8:	ff 4f       	sbci	r31, 0xFF	; 255
 4fa:	90 81       	ld	r25, Z
 4fc:	80 91 00 00 	lds	r24, 0x0000
 500:	98 17       	cp	r25, r24
 502:	01 f0       	breq	.+0      	; 0x504 <receivePacket+0x158>
 504:	00 c0       	rjmp	.+0      	; 0x506 <receivePacket+0x15a>
			c->receive_state = PR_CRC1;
 506:	ee 81       	ldd	r30, Y+6	; 0x06
 508:	ff 81       	ldd	r31, Y+7	; 0x07
 50a:	86 e0       	ldi	r24, 0x06	; 6
 50c:	81 83       	std	Z+1, r24	; 0x01
			index = 0;
 50e:	10 92 00 00 	sts	0x0000, r1
 512:	00 c0       	rjmp	.+0      	; 0x514 <receivePacket+0x168>

	} break;

	case PR_CRC1: {

		c->receive_state = PR_CRC2;
 514:	ee 81       	ldd	r30, Y+6	; 0x06
 516:	ff 81       	ldd	r31, Y+7	; 0x07
 518:	87 e0       	ldi	r24, 0x07	; 7
 51a:	81 83       	std	Z+1, r24	; 0x01
		c->ip.crc = tUDR;
 51c:	8d 81       	ldd	r24, Y+5	; 0x05
 51e:	28 2f       	mov	r18, r24
 520:	30 e0       	ldi	r19, 0x00	; 0
 522:	8e 81       	ldd	r24, Y+6	; 0x06
 524:	9f 81       	ldd	r25, Y+7	; 0x07
 526:	fc 01       	movw	r30, r24
 528:	e8 5a       	subi	r30, 0xA8	; 168
 52a:	ff 4f       	sbci	r31, 0xFF	; 255
 52c:	31 83       	std	Z+1, r19	; 0x01
 52e:	20 83       	st	Z, r18
 530:	00 c0       	rjmp	.+0      	; 0x532 <receivePacket+0x186>

	} break;

	case PR_CRC2: {

		uint16_t p = tUDR;
 532:	8d 81       	ldd	r24, Y+5	; 0x05
 534:	88 2f       	mov	r24, r24
 536:	90 e0       	ldi	r25, 0x00	; 0
 538:	9c 83       	std	Y+4, r25	; 0x04
 53a:	8b 83       	std	Y+3, r24	; 0x03
		c->ip.crc |= (p<<8);
 53c:	8e 81       	ldd	r24, Y+6	; 0x06
 53e:	9f 81       	ldd	r25, Y+7	; 0x07
 540:	fc 01       	movw	r30, r24
 542:	e8 5a       	subi	r30, 0xA8	; 168
 544:	ff 4f       	sbci	r31, 0xFF	; 255
 546:	20 81       	ld	r18, Z
 548:	31 81       	ldd	r19, Z+1	; 0x01
 54a:	8b 81       	ldd	r24, Y+3	; 0x03
 54c:	9c 81       	ldd	r25, Y+4	; 0x04
 54e:	98 2f       	mov	r25, r24
 550:	88 27       	eor	r24, r24
 552:	28 2b       	or	r18, r24
 554:	39 2b       	or	r19, r25
 556:	8e 81       	ldd	r24, Y+6	; 0x06
 558:	9f 81       	ldd	r25, Y+7	; 0x07
 55a:	fc 01       	movw	r30, r24
 55c:	e8 5a       	subi	r30, 0xA8	; 168
 55e:	ff 4f       	sbci	r31, 0xFF	; 255
 560:	31 83       	std	Z+1, r19	; 0x01
 562:	20 83       	st	Z, r18


		uint16_t crc = makeCRC(&c->ip.data,c->ip.len);
 564:	8e 81       	ldd	r24, Y+6	; 0x06
 566:	9f 81       	ldd	r25, Y+7	; 0x07
 568:	9c 01       	movw	r18, r24
 56a:	2a 5c       	subi	r18, 0xCA	; 202
 56c:	3f 4f       	sbci	r19, 0xFF	; 255
 56e:	8e 81       	ldd	r24, Y+6	; 0x06
 570:	9f 81       	ldd	r25, Y+7	; 0x07
 572:	fc 01       	movw	r30, r24
 574:	ea 5a       	subi	r30, 0xAA	; 170
 576:	ff 4f       	sbci	r31, 0xFF	; 255
 578:	40 81       	ld	r20, Z
 57a:	c9 01       	movw	r24, r18
 57c:	64 2f       	mov	r22, r20
 57e:	0e 94 00 00 	call	0	; 0x0 <crc16_update>
 582:	9a 83       	std	Y+2, r25	; 0x02
 584:	89 83       	std	Y+1, r24	; 0x01

		if (crc == c->ip.crc) {
 586:	8e 81       	ldd	r24, Y+6	; 0x06
 588:	9f 81       	ldd	r25, Y+7	; 0x07
 58a:	fc 01       	movw	r30, r24
 58c:	e8 5a       	subi	r30, 0xA8	; 168
 58e:	ff 4f       	sbci	r31, 0xFF	; 255
 590:	20 81       	ld	r18, Z
 592:	31 81       	ldd	r19, Z+1	; 0x01
 594:	89 81       	ldd	r24, Y+1	; 0x01
 596:	9a 81       	ldd	r25, Y+2	; 0x02
 598:	28 17       	cp	r18, r24
 59a:	39 07       	cpc	r19, r25
 59c:	01 f4       	brne	.+0      	; 0x59e <receivePacket+0x1f2>

			c->receive_state = PR_PACKET_RECEIVED;
 59e:	ee 81       	ldd	r30, Y+6	; 0x06
 5a0:	ff 81       	ldd	r31, Y+7	; 0x07
 5a2:	88 e0       	ldi	r24, 0x08	; 8
 5a4:	81 83       	std	Z+1, r24	; 0x01
			c->packets_received++;
 5a6:	ee 81       	ldd	r30, Y+6	; 0x06
 5a8:	ff 81       	ldd	r31, Y+7	; 0x07
 5aa:	84 a5       	ldd	r24, Z+44	; 0x2c
 5ac:	95 a5       	ldd	r25, Z+45	; 0x2d
 5ae:	a6 a5       	ldd	r26, Z+46	; 0x2e
 5b0:	b7 a5       	ldd	r27, Z+47	; 0x2f
 5b2:	01 96       	adiw	r24, 0x01	; 1
 5b4:	a1 1d       	adc	r26, r1
 5b6:	b1 1d       	adc	r27, r1
 5b8:	ee 81       	ldd	r30, Y+6	; 0x06
 5ba:	ff 81       	ldd	r31, Y+7	; 0x07
 5bc:	84 a7       	std	Z+44, r24	; 0x2c
 5be:	95 a7       	std	Z+45, r25	; 0x2d
 5c0:	a6 a7       	std	Z+46, r26	; 0x2e
 5c2:	b7 a7       	std	Z+47, r27	; 0x2f
 5c4:	00 c0       	rjmp	.+0      	; 0x5c6 <receivePacket+0x21a>

		} else {

			// chyba CRC :-(
			c->packets_bad_received++;
 5c6:	ee 81       	ldd	r30, Y+6	; 0x06
 5c8:	ff 81       	ldd	r31, Y+7	; 0x07
 5ca:	80 a9       	ldd	r24, Z+48	; 0x30
 5cc:	91 a9       	ldd	r25, Z+49	; 0x31
 5ce:	01 96       	adiw	r24, 0x01	; 1
 5d0:	ee 81       	ldd	r30, Y+6	; 0x06
 5d2:	ff 81       	ldd	r31, Y+7	; 0x07
 5d4:	91 ab       	std	Z+49, r25	; 0x31
 5d6:	80 ab       	std	Z+48, r24	; 0x30
			c->receive_state = PR_READY;
 5d8:	ee 81       	ldd	r30, Y+6	; 0x06
 5da:	ff 81       	ldd	r31, Y+7	; 0x07
 5dc:	8a e0       	ldi	r24, 0x0A	; 10
 5de:	81 83       	std	Z+1, r24	; 0x01

	} // switch

	//}

}
 5e0:	29 96       	adiw	r28, 0x09	; 9
 5e2:	0f b6       	in	r0, 0x3f	; 63
 5e4:	f8 94       	cli
 5e6:	de bf       	out	0x3e, r29	; 62
 5e8:	0f be       	out	0x3f, r0	; 63
 5ea:	cd bf       	out	0x3d, r28	; 61
 5ec:	cf 91       	pop	r28
 5ee:	df 91       	pop	r29
 5f0:	08 95       	ret

000005f2 <receiveTimeout>:

void receiveTimeout(volatile tcomm_state *c) {
 5f2:	df 93       	push	r29
 5f4:	cf 93       	push	r28
 5f6:	00 d0       	rcall	.+0      	; 0x5f8 <receiveTimeout+0x6>
 5f8:	00 d0       	rcall	.+0      	; 0x5fa <receiveTimeout+0x8>
 5fa:	cd b7       	in	r28, 0x3d	; 61
 5fc:	de b7       	in	r29, 0x3e	; 62
 5fe:	9a 83       	std	Y+2, r25	; 0x02
 600:	89 83       	std	Y+1, r24	; 0x01

	if (c->receive_state!=PR_PACKET_RECEIVED) {
 602:	e9 81       	ldd	r30, Y+1	; 0x01
 604:	fa 81       	ldd	r31, Y+2	; 0x02
 606:	81 81       	ldd	r24, Z+1	; 0x01
 608:	88 30       	cpi	r24, 0x08	; 8
 60a:	01 f0       	breq	.+0      	; 0x60c <receiveTimeout+0x1a>

		// chyba pøi pøenosu
		if (c->receive_timeout++ > MAXTIMEOUT) {
 60c:	e9 81       	ldd	r30, Y+1	; 0x01
 60e:	fa 81       	ldd	r31, Y+2	; 0x02
 610:	82 81       	ldd	r24, Z+2	; 0x02
 612:	8c 83       	std	Y+4, r24	; 0x04
 614:	1b 82       	std	Y+3, r1	; 0x03
 616:	8c 81       	ldd	r24, Y+4	; 0x04
 618:	8b 30       	cpi	r24, 0x0B	; 11
 61a:	00 f0       	brcs	.+0      	; 0x61c <receiveTimeout+0x2a>
 61c:	81 e0       	ldi	r24, 0x01	; 1
 61e:	8b 83       	std	Y+3, r24	; 0x03
 620:	8c 81       	ldd	r24, Y+4	; 0x04
 622:	8f 5f       	subi	r24, 0xFF	; 255
 624:	e9 81       	ldd	r30, Y+1	; 0x01
 626:	fa 81       	ldd	r31, Y+2	; 0x02
 628:	82 83       	std	Z+2, r24	; 0x02
 62a:	8b 81       	ldd	r24, Y+3	; 0x03
 62c:	88 23       	and	r24, r24
 62e:	01 f0       	breq	.+0      	; 0x630 <receiveTimeout+0x3e>

			c->receive_timeout = 0;
 630:	e9 81       	ldd	r30, Y+1	; 0x01
 632:	fa 81       	ldd	r31, Y+2	; 0x02
 634:	12 82       	std	Z+2, r1	; 0x02
			c->packets_timeouted++;
 636:	e9 81       	ldd	r30, Y+1	; 0x01
 638:	fa 81       	ldd	r31, Y+2	; 0x02
 63a:	82 a9       	ldd	r24, Z+50	; 0x32
 63c:	93 a9       	ldd	r25, Z+51	; 0x33
 63e:	01 96       	adiw	r24, 0x01	; 1
 640:	e9 81       	ldd	r30, Y+1	; 0x01
 642:	fa 81       	ldd	r31, Y+2	; 0x02
 644:	93 ab       	std	Z+51, r25	; 0x33
 646:	82 ab       	std	Z+50, r24	; 0x32
			c->receive_state = PR_TIMEOUT;
 648:	e9 81       	ldd	r30, Y+1	; 0x01
 64a:	fa 81       	ldd	r31, Y+2	; 0x02
 64c:	89 e0       	ldi	r24, 0x09	; 9
 64e:	81 83       	std	Z+1, r24	; 0x01

		}

	}

}
 650:	0f 90       	pop	r0
 652:	0f 90       	pop	r0
 654:	0f 90       	pop	r0
 656:	0f 90       	pop	r0
 658:	cf 91       	pop	r28
 65a:	df 91       	pop	r29
 65c:	08 95       	ret
